{"mappings":"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","sources":["/home/runner/work/fundude/fundude/node_modules/@parcel/scope-hoisting/lib/helpers.js","node_modules/@babel/runtime/helpers/esm/extends.js","node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","node_modules/memoize-one/dist/memoize-one.esm.js","node_modules/react-window/dist/index.esm.js","node_modules/react-use-dimensions/es/index.js","web/Debug/util.ts","web/Debug/Disassembler.tsx","web/Debug/Cpu.tsx","web/Form.tsx","web/Debug/Mmu.tsx","web/Debug/index.tsx"],"names":["$parcel$interopDefault","a","__esModule","default","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_assertThisInitialized","self","ReferenceError","areInputsEqual","newInputs","lastInputs","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","size","defaultItemKey","_ref","columnIndex","data","rowIndex","createGridComponent","_ref2","_class","_temp","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","Grid","props","_this","_instanceProps","$dd4369f6ed11c3d96522c223368b8e20$export$default","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","scrollLeft","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","$c7bd1558389d56459daff0cb5aa9$export$default","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","style","_style","_this$props","columnWidth","direction","rowHeight","itemStyleCache","_getItemStyleCache","position","top","height","width","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientWidth","scrollWidth","setState","prevState","calculatedScrollLeft","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","$d723b4083c2c247473de379cc03d7d3b$export$default","getDerivedStateFromProps","nextProps","validateSharedProps","_proto","scrollTo","_ref3","undefined","Math","max","scrollToItem","_ref4","_ref4$align","align","_this$props2","columnCount","rowCount","_this$state","scrollbarSize","recalculate","div","document","createElement","overflow","body","appendChild","offsetWidth","removeChild","getScrollbarSize","min","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","render","_this$props4","children","className","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","push","$a068c315cb027fd29b08321844d901a$init","estimatedTotalWidth","$ff819e2cc95a617f59a7185f26abe764$export$default","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowsCount","_this$state5","PureComponent","defaultProps","_ref5","_ref6","defaultItemKey$1","index","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","List","scrollDirection","scrollOffset","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","itemSize","layout","_offset","isHorizontal","_onScrollHorizontal","_onScrollVertical","validateSharedProps$1","itemCount","_this$_getRangeToRend","_getRangeToRender","_index","estimatedTotalSize","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_scrollDirection","_scrollOffset","FixedSizeGrid","_ref7","instanceProps","maxOffset","minOffset","round","_ref8","_ref9","floor","_ref10","left","_ref11","_ref12","_ref13","FixedSizeList","offset","getDimensionObject","node","rect","getBoundingClientRect","x","y","right","bottom","useDimensions","_ref$liveMeasure","liveMeasure","_useState","useState","dimensions","setDimensions","_useState2","setNode","useCallback","useLayoutEffect","measure","window","addEventListener","removeEventListener","hex2","n","toString","toUpperCase","padStart","hex4","CSS","root","$d354603b2eacf81cbdde2eb7fd622$init","rule","fontFamily","display","flex","child","cursor","&.active","boxShadow","childSegment","margin","breakpoint","alignSelf","background","borderRadius","Disassembler","currentAddr","fd","cpu","PC","assembly","setAssembly","useEffect","disassemble","$d58412425ccdae30d3f446421289b8$init","fromEntries","cart","listRef","useRef","rootRef","$e610a77945b71f621ec81e804b0e5$export$default","$f04842814e4e6a390ad2fe39f0b3$$interop$default","$f04842814e4e6a390ad2fe39f0b3$init","$b2e1584b5fe8e4fc1f07d70549b589d9$export$FixedSizeList","onClick","setBreakpoint","concat","$a760d6dcbc6420ad0861b2412e989ba1$export$hex4","$a760d6dcbc6420ad0861b2412e989ba1$export$hex2","textAlign","justifyContent","Cpu","reg","AF","BC","DE","HL","SP","Form","onSubmit","$ff918dd528a1ccc424899102b197f34$var$_objectWithoutProperties","$ff918dd528a1ccc424899102b197f34$var$_extends","preventDefault","FormData","flexDirection","maxHeight","controls","custom","output","outputCell","hl","backgroundColor","sp","REGION_CSS","vram","ram","oam","io","himem","MEMLOC_CSS","segment","$a242b3e18a5a8414053f7c404c4ba3a7$init","MMU_OFFSETS","segments","loc","end","name","MmuOutput","gridRef","createRef","mem","focus","shift","$b2e1584b5fe8e4fc1f07d70549b589d9$export$FixedSizeGrid","highlightClasses","Mmu","setFocus","map","$ff918dd528a1ccc424899102b197f34$export$default","search","parseInt","String","pattern","placeholder","$b38127f0c876c2bccadcbca68fe72620$var$MmuOutput","mmu","[object Object]","base","displays","alignItems","displayPatterns","Left","run","pause","useContext","$b224d85e962b1a31315baba43966f45$init","Context","step","stepMs","fn","t","val","console","log","$d9a445a4657d5013ad4468228c9ff89c$export$default","$e3e693fc957180de360d17032ac85e4e$export$default","Displays","setRerender","forceRender","prev","changed","add","remove","scx","scy","Fragment","$b9f4273d59134a4070119fe6049d387$init","pixels","sprites","viewports","gridColor","Right","$d03402a4bac4d17cf9a6711a8a435905$var$Displays","$b38127f0c876c2bccadcbca68fe72620$export$default"],"version":3,"file":"Debug.d22f7cc8.js.map","sourcesContent":[null,"export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","function areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _style;\n\n          itemStyleCache[key] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // HACK According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n          // See https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            if (scrollLeft <= 0) {\n              calculatedScrollLeft = -scrollLeft;\n            } else {\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n            }\n          }\n\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: scrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (typeof initialScrollLeft === 'number' && this._outerRef != null) {\n        this._outerRef.scrollLeft = initialScrollLeft;\n      }\n\n      if (typeof initialScrollTop === 'number' && this._outerRef != null) {\n        this._outerRef.scrollTop = initialScrollTop;\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef !== null) {\n        this._outerRef.scrollLeft = scrollLeft;\n        this._outerRef.scrollTop = scrollTop;\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : '',\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanCount = _ref5.overscanCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnsCount and overscanRowsCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName$1 =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _style;\n\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          itemStyleCache[index] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // HACK According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // Chrome does not seem to adhere; its scrolLeft values are positive (measured relative to the left).\n          // See https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            if (scrollLeft <= 0) {\n              scrollOffset = -scrollOffset;\n            } else {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n            }\n          }\n\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var scrollTop = event.currentTarget.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollTop ? 'forward' : 'backward',\n            scrollOffset: scrollTop,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef !== null) {\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          this._outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          this._outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef !== null) {\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          this._outerRef.scrollLeft = scrollOffset;\n        } else {\n          this._outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : '',\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var maxOffset = Math.max(0, Math.min(columnCount * columnWidth - width, columnIndex * columnWidth));\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (scrollLeft - minOffset < maxOffset - scrollLeft) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var maxOffset = Math.max(0, Math.min(rowCount * rowHeight - height, rowIndex * rowHeight));\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (scrollTop - minOffset < maxOffset - scrollTop) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    return Math.max(0, Math.min(columnCount - 1, startIndex + Math.floor((width + (scrollLeft - left)) / columnWidth)));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var left = startIndex * rowHeight;\n    return Math.max(0, Math.min(rowCount - 1, startIndex + Math.floor((height + (scrollTop - left)) / rowHeight)));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize,\n        size = _ref.size;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize,\n        size = _ref2.size;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var maxOffset = Math.max(0, Math.min(itemCount * itemSize - size, index * itemSize));\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    return Math.max(0, Math.min(itemCount - 1, startIndex + Math.floor((size + (scrollOffset - offset)) / itemSize)));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };\n","import { useState, useCallback, useLayoutEffect } from \"react\";\nfunction getDimensionObject(node) {\n    var rect = node.getBoundingClientRect();\n    return {\n        width: rect.width,\n        height: rect.height,\n        top: \"x\" in rect ? rect.x : rect.top,\n        left: \"y\" in rect ? rect.y : rect.left,\n        x: \"x\" in rect ? rect.x : rect.left,\n        y: \"y\" in rect ? rect.y : rect.top,\n        right: rect.right,\n        bottom: rect.bottom\n    };\n}\nfunction useDimensions() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$liveMeasure = _ref.liveMeasure,\n        liveMeasure = _ref$liveMeasure === undefined ? true : _ref$liveMeasure;\n\n    var _useState = useState({}),\n        dimensions = _useState[0],\n        setDimensions = _useState[1];\n\n    var _useState2 = useState(null),\n        node = _useState2[0],\n        setNode = _useState2[1];\n\n    var ref = useCallback(function (node) {\n        setNode(node);\n    }, []);\n    useLayoutEffect(function () {\n        if (node) {\n            var measure = function measure() {\n                return window.requestAnimationFrame(function () {\n                    return setDimensions(getDimensionObject(node));\n                });\n            };\n            measure();\n            if (liveMeasure) {\n                window.addEventListener(\"resize\", measure);\n                window.addEventListener(\"scroll\", measure);\n                return function () {\n                    window.removeEventListener(\"resize\", measure);\n                    window.removeEventListener(\"scroll\", measure);\n                };\n            }\n        }\n    }, [node]);\n    return [ref, dimensions, node];\n}\nexport default useDimensions;\n//# sourceMappingURL=index.js.map","export function hex2(n: number) {\n  return n\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, \"0\");\n}\n\nexport function hex4(n: number) {\n  return n\n    .toString(16)\n    .toUpperCase()\n    .padStart(4, \"0\");\n}\n","import React from \"react\";\nimport cx from \"classnames\";\nimport { FixedSizeList } from \"react-window\";\nimport useDimensions from \"react-use-dimensions\";\n\nimport nano from \"../nano\";\nimport { fromEntries } from \"../smalldash\";\n\nimport FundudeWasm from \"../../wasm\";\nimport { hex2, hex4 } from \"./util\";\n\nconst CSS = {\n  root: nano.rule({\n    fontFamily: \"monospace\",\n    display: \"flex\",\n    flex: \"1 1 auto\"\n  }),\n  child: nano.rule({\n    display: \"flex\",\n    cursor: \"pointer\",\n\n    \"&.active\": {\n      boxShadow: \"inset 0 0 0 1px black\"\n    }\n  }),\n  childSegment: nano.rule({\n    margin: \"0 4px\"\n  }),\n  breakpoint: nano.rule({\n    display: \"inline-block\",\n    width: \"10px\",\n    height: \"10px\",\n    alignSelf: \"center\",\n\n    \"&.active\": {\n      background: \"red\",\n      borderRadius: \"100%\"\n    }\n  })\n};\n\nexport default function Disassembler(props: { fd: FundudeWasm }) {\n  const currentAddr = props.fd.cpu().PC();\n  const [assembly, setAssembly] = React.useState({} as Record<number, string>);\n\n  React.useEffect(() => {\n    const assembly = props.fd.disassemble();\n    setAssembly(fromEntries(assembly));\n  }, [props.fd.cart]);\n\n  const listRef = React.useRef<FixedSizeList>();\n  React.useEffect(() => {\n    listRef.current && listRef.current.scrollToItem(currentAddr);\n  }, [listRef.current, currentAddr]);\n\n  const [rootRef, { height }] = useDimensions();\n\n  return (\n    <div ref={rootRef} className={CSS.root}>\n      <FixedSizeList\n        ref={listRef}\n        height={height || 0}\n        width={240}\n        itemSize={15}\n        itemCount={props.fd.cart.length}\n      >\n        {({ index, style }) => (\n          <div\n            style={style}\n            className={cx(CSS.child, index === currentAddr && \"active\")}\n            onClick={() => props.fd.setBreakpoint(index)}\n          >\n            <i\n              className={`${CSS.breakpoint} ${\n                props.fd.breakpoint === index ? \"active\" : \"\"\n              }`}\n            />\n            <span className={CSS.childSegment}>${hex4(index)}</span>\n            <span className={CSS.childSegment}>\n              {hex2(props.fd.cart[index])}\n            </span>\n            <strong className={CSS.childSegment}>\n              {assembly[index] || \"\"}\n            </strong>\n          </div>\n        )}\n      </FixedSizeList>\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport nano from \"../nano\";\nimport { hex4 } from \"./util\";\n\nimport FundudeWasm from \"../../wasm\";\n\nconst CSS = {\n  root: nano.rule({\n    display: \"flex\",\n    textAlign: \"center\",\n    fontFamily: \"monospace\",\n    justifyContent: \"space-between\"\n  })\n};\n\nexport default function Cpu(props: {\n  reg: () => ReturnType<FundudeWasm[\"cpu\"]>;\n}) {\n  const reg = props.reg();\n  return (\n    <dl className={CSS.root}>\n      <div>\n        <dt>AF</dt>\n        <dd>{hex4(reg.AF())}</dd>\n      </div>\n      <div>\n        <dt>BC</dt>\n        <dd>{hex4(reg.BC())}</dd>\n      </div>\n      <div>\n        <dt>DE</dt>\n        <dd>{hex4(reg.DE())}</dd>\n      </div>\n      <div>\n        <dt>HL</dt>\n        <dd>{hex4(reg.HL())}</dd>\n      </div>\n      <div>\n        <dt>SP</dt>\n        <dd>{hex4(reg.SP())}</dd>\n      </div>\n      <div>\n        <dt>PC</dt>\n        <dd>{hex4(reg.PC())}</dd>\n      </div>\n    </dl>\n  );\n}\n","import React from \"react\";\n\nimport { fromEntries } from \"./smalldash\";\n\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\n\nexport default function Form({\n  onSubmit,\n  children,\n  ...props\n}: Omit<React.HTMLAttributes<HTMLFormElement>, \"onSubmit\"> & {\n  onSubmit: (data: Record<string, FormDataEntryValue>) => any;\n  children: React.ReactNode;\n}) {\n  function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n    const fd = new FormData(event.currentTarget);\n    onSubmit(fromEntries(fd));\n  }\n  return (\n    <form onSubmit={handleSubmit} {...props}>\n      {children}\n    </form>\n  );\n}\n","import React from \"react\";\nimport cx from \"classnames\";\nimport { FixedSizeGrid } from \"react-window\";\nimport useDimensions from \"react-use-dimensions\";\n\nimport nano from \"../nano\";\nimport { hex2, hex4 } from \"./util\";\n\nimport FundudeWasm, { MMU_OFFSETS } from \"../../src/wasm\";\nimport Form from \"../Form\";\n\nconst CSS = {\n  root: nano.rule({\n    display: \"flex\",\n    flexDirection: \"column\",\n    flex: \"1 1 0\",\n    maxHeight: \"100vh\",\n  }),\n  controls: nano.rule({\n    display: \"flex\",\n    fontFamily: \"monospace\",\n    textAlign: \"center\",\n  }),\n  custom: nano.rule({\n    display: \"flex\",\n    width: \"50px\",\n  }),\n\n  output: nano.rule({\n    fontFamily: \"monospace\",\n    textAlign: \"center\",\n    flex: \"1 1 0\",\n  }),\n  outputCell: nano.rule({\n    \"&.active\": {\n      boxShadow: \"inset 0 0 0 1px black\",\n    },\n  }),\n\n  hl: nano.rule({\n    backgroundColor: \"#d0ffff\",\n  }),\n  sp: nano.rule({\n    backgroundColor: \"#ffd0ff\",\n  }),\n};\n\nconst REGION_CSS: Record<string, string> = {\n  vram: nano.rule({ backgroundColor: \"#ffaaaa\" }),\n  ram: nano.rule({ backgroundColor: \"#ffffaa\" }),\n  oam: nano.rule({ backgroundColor: \"#aaffaa\" }),\n  io: nano.rule({ backgroundColor: \"#aaffff\" }),\n  himem: nano.rule({ backgroundColor: \"#aaaaff\" }),\n};\n\nconst MEMLOC_CSS: Record<number, string> = {};\nfor (const segment of MMU_OFFSETS.segments) {\n  for (let loc = segment.start; loc <= segment.end; loc++) {\n    MEMLOC_CSS[loc] = REGION_CSS[segment.name];\n  }\n}\n\nconst WIDTH = 16;\n\nfunction MmuOutput(props: {\n  mem: () => Uint8Array;\n  focus: number;\n  highlightClasses: Record<number, string>;\n}) {\n  const [rootRef, { height }] = useDimensions();\n  const gridRef = React.createRef<FixedSizeGrid>();\n\n  const mem = props.mem();\n\n  React.useEffect(() => {\n    const i = props.focus - MMU_OFFSETS.shift;\n    gridRef.current &&\n      gridRef.current.scrollToItem({\n        columnIndex: i % WIDTH,\n        rowIndex: i / WIDTH,\n      });\n  }, [gridRef.current, props.focus]);\n\n  return (\n    <div ref={rootRef} className={CSS.output}>\n      <FixedSizeGrid\n        ref={gridRef}\n        height={height || 0}\n        width={430}\n        columnCount={WIDTH}\n        rowCount={mem.length / WIDTH}\n        columnWidth={25}\n        rowHeight={15}\n      >\n        {({ columnIndex, rowIndex, style }) => {\n          const i = rowIndex * WIDTH + columnIndex;\n          const loc = i + MMU_OFFSETS.shift;\n          return (\n            <div\n              style={style}\n              className={cx(\n                CSS.outputCell,\n                props.highlightClasses[loc],\n                MEMLOC_CSS[loc],\n                loc === props.focus && \"active\"\n              )}\n            >\n              {hex2(props.mem[i] || 0)}\n            </div>\n          );\n        }}\n      </FixedSizeGrid>\n    </div>\n  );\n}\n\nexport default function Mmu(props: { fd: FundudeWasm }) {\n  const [focus, setFocus] = React.useState(0);\n  const cpu = props.fd.cpu();\n  return (\n    <div className={CSS.root}>\n      <div className={CSS.controls}>\n        {MMU_OFFSETS.segments.map((segment) => (\n          <div key={segment.name} className={REGION_CSS[segment.name]}>\n            <div>{segment.name}</div>\n            <button onClick={() => setFocus(segment.start)}>\n              {hex4(segment.start)}\n            </button>\n            <button onClick={() => setFocus(segment.end)}>\n              {hex4(segment.end)}\n            </button>\n          </div>\n        ))}\n        <Form\n          className={CSS.custom}\n          onSubmit={({ search }) => setFocus(parseInt(String(search), 16))}\n        >\n          <input name=\"search\" pattern=\"[0-9a-fA-F]*\" placeholder=\"Addr\" />\n        </Form>\n      </div>\n      <MmuOutput\n        mem={() => props.fd.mmu()}\n        focus={focus}\n        highlightClasses={{\n          [cpu.HL()]: CSS.hl,\n          [cpu.SP()]: CSS.sp,\n        }}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport nano from \"../nano\";\n\nimport FD from \"../../src/wasm/react\";\nimport Display from \"../Display\";\nimport Disassembler from \"./Disassembler\";\nimport Cpu from \"./Cpu\";\nimport Mmu from \"./Mmu\";\nimport FundudeWasm from \"../../src/wasm\";\n\nconst CSS = {\n  base: nano.rule({\n    display: \"flex\",\n    flexDirection: \"column\",\n    position: \"relative\",\n    margin: \"0 50px\",\n  }),\n\n  controls: nano.rule({\n    display: \"flex\",\n    justifyContent: \"space-between\",\n  }),\n\n  displays: nano.rule({\n    position: \"relative\",\n    display: \"flex\",\n    justifyContent: \"space-between\",\n    alignItems: \"flex-end\",\n  }),\n\n  displayPatterns: nano.rule({\n    position: \"absolute\",\n    top: 0,\n    left: \"100%\",\n  }),\n};\n\nfunction timed<T, R>(fn: (T) => R): (T) => R {\n  return function (t: T) {\n    const start = Date.now();\n    const val = fn(t);\n    console.log(`${(Date.now() - start) / 1000}s realtime -- 250s ingame`);\n    return val;\n  };\n}\n\nexport function Left() {\n  const { fd, run, pause } = React.useContext(FD.Context);\n  return (\n    <div className={CSS.base}>\n      <div className={CSS.controls}>\n        <div>\n          <button onClick={run}>&#9658;</button>\n          <button onClick={pause}>&#10073;&#10073;</button>\n        </div>\n        <div>\n          <button onClick={() => fd.step() && pause()}>Step</button>\n          <button onClick={() => fd.stepMs(16.75) && pause()}>Frame</button>\n          <button onClick={() => fd.stepMs(1000) && pause()}>Sec</button>\n          <button onClick={timed(() => fd.stepMs(250000) && pause())}>\n            &#9992;\n          </button>\n        </div>\n      </div>\n      <Cpu reg={() => fd.cpu()} />\n      <Disassembler fd={fd} />\n    </div>\n  );\n}\n\nfunction Displays(props: { fd: FundudeWasm }) {\n  const { fd } = React.useContext(FD.Context);\n\n  const [_, setRerender] = React.useState(false);\n  React.useEffect(() => {\n    function forceRender() {\n      setRerender((prev) => !prev);\n    }\n    fd.changed.add(forceRender);\n    return () => fd.changed.remove(forceRender);\n  }, []);\n\n  const mmu = fd.mmu();\n\n  const scx = mmu[0xff43 - 0x8000];\n  const scy = mmu[0xff42 - 0x8000];\n\n  return (\n    <React.Fragment>\n      {/* TODO: convert to tile display */}\n      {/* <Display\n        className={CSS.displayPatterns}\n        pixels={() => fd.patterns()}\n        gridColor=\"lightgray\"\n      /> */}\n      <Display\n        pixels={() => fd.sprites()}\n        viewports={[[8, 16]]}\n        gridColor=\"lightgray\"\n      />\n      <div className={CSS.displays}>\n        <Display\n          pixels={() => fd.background()}\n          viewports={[\n            [scx, scy],\n            [scx - 256, scy],\n            [scx, scy - 256],\n            [scx - 256, scy - 256],\n          ]}\n          gridColor=\"lightgray\"\n        />\n        <Display\n          pixels={() => fd.window()}\n          gridColor=\"lightgray\"\n          viewports={[]}\n        />\n      </div>\n    </React.Fragment>\n  );\n}\n\nexport function Right() {\n  const { fd } = React.useContext(FD.Context);\n\n  return (\n    <div className={CSS.base}>\n      <Displays fd={fd} />\n      <Mmu fd={fd} />\n    </div>\n  );\n}\n\nexport default { Left, Right };\n"]}